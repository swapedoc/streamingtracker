# dashboard_v3.py - Two-Tab Dashboard for V3.0
# Run with: streamlit run dashboard_v3.py

import streamlit as st
import pandas as pd
import os
from datetime import datetime
import plotly.express as px
import plotly.graph_objects as go
from supabase import create_client, Client
from dotenv import load_dotenv

load_dotenv()

# Page config
st.set_page_config(
    page_title="Streaming Tracker V3.0",
    page_icon="üé¨",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS
st.markdown("""
<style>
    .main-header {
        font-size: 3rem;
        font-weight: bold;
        text-align: center;
        margin-bottom: 0.5rem;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    .sub-header {
        text-align: center;
        color: #666;
        margin-bottom: 2rem;
    }
</style>
""", unsafe_allow_html=True)

# ============================================================================
# DATA LOADING
# ============================================================================

@st.cache_data(ttl=300)
def load_watch_now_data():
    """Load Watch Now data (scores + reviews)"""
    supabase_url = os.getenv('SUPABASE_URL')
    supabase_key = os.getenv('SUPABASE_KEY')
    
    if not supabase_url or not supabase_key:
        return None, None, "No Supabase credentials"
    
    try:
        supabase: Client = create_client(supabase_url, supabase_key)
        
        # Load scores with content info
        scores_result = supabase.table('scores') \
            .select('*, content(*)') \
            .order('final_score', desc=True) \
            .execute()
        
        if not scores_result.data:
            return None, None, "No data found. Run streaming_tracker_v3.py first"
        
        # Parse nested content
        scores_data = []
        for row in scores_result.data:
            content = row.pop('content', {})
            scores_data.append({
                **row,
                'title': content.get('title', 'Unknown'),
                'platform': content.get('platform', 'Unknown'),
                'content_type': content.get('content_type', 'unknown'),
                'release_year': content.get('release_year'),
                'tmdb_id': content.get('tmdb_id'),
                'poster_path': content.get('poster_path'),
                'overview': content.get('overview'),
                'imdb_rating': content.get('imdb_rating')
            })
        
        scores_df = pd.DataFrame(scores_data)
        
        # Load reviews
        reviews_result = supabase.table('reviews') \
            .select('*, content(title, platform)') \
            .order('created_at', desc=True) \
            .execute()
        
        reviews_data = []
        for row in reviews_result.data:
            content = row.pop('content', {})
            reviews_data.append({
                **row,
                'content_title': content.get('title', 'Unknown'),
                'content_platform': content.get('platform', 'Unknown')
            })
        
        reviews_df = pd.DataFrame(reviews_data)
        
        return scores_df, reviews_df, None
        
    except Exception as e:
        return None, None, f"Database error: {str(e)}"

@st.cache_data(ttl=300)
def load_discover_data():
    """Load Discover data"""
    supabase_url = os.getenv('SUPABASE_URL')
    supabase_key = os.getenv('SUPABASE_KEY')
    
    if not supabase_url or not supabase_key:
        return None, "No Supabase credentials"
    
    try:
        supabase: Client = create_client(supabase_url, supabase_key)
        result = supabase.table('discover_content') \
            .select('*') \
            .order('popularity', desc=True) \
            .execute()
        
        if not result.data:
            return None, "No discover data found. Run streaming_tracker_v3.py first"
        
        return pd.DataFrame(result.data), None
    except Exception as e:
        return None, f"Database error: {str(e)}"

# ============================================================================
# MAIN DASHBOARD
# ============================================================================

def main():
    # Header
    st.markdown('<p class="main-header">üé¨ Streaming Tracker V3.0</p>', unsafe_allow_html=True)
    st.markdown('<p class="sub-header">Watch Now ‚Ä¢ Discover</p>', unsafe_allow_html=True)
    
    # Create tabs
    tab1, tab2 = st.tabs(["üì∫ Watch Now", "üîç Discover"])
    
    with tab1:
        render_watch_now_tab()
    
    with tab2:
        render_discover_tab()

# ============================================================================
# WATCH NOW TAB
# ============================================================================

def render_watch_now_tab():
    st.header("üì∫ Watch Now - Trending with Reviews")
    st.caption("Trending content scored with YouTube + Reddit reviews")
    
    # Load data
    scores_df, reviews_df, error = load_watch_now_data()
    
    if error:
        st.error(f"‚ö†Ô∏è {error}")
        st.info("""
        **To fix this:**
        1. Make sure `.env` file has SUPABASE_URL and SUPABASE_KEY
        2. Run: `python3 streaming_tracker_v3.py`
        3. Wait for Watch Now flow to complete
        4. Refresh this page
        """)
        return
    
    # Success message
    total_content = len(scores_df)
    total_reviews = len(reviews_df) if reviews_df is not None else 0
    st.success(f"‚úÖ Loaded {total_content} titles ‚Ä¢ {total_reviews} reviews")
    
    # Sidebar filters
    st.sidebar.header("üì∫ Watch Now Filters")
    
    # Platform filter
    platforms = ['All'] + sorted(scores_df['platform'].unique().tolist())
    selected_platform = st.sidebar.selectbox("Platform", platforms, key="watch_platform")
    
    # Content type filter
    content_types = ['All'] + sorted(scores_df['content_type'].unique().tolist())
    selected_type = st.sidebar.selectbox("Type", content_types, key="watch_type")
    
    # Score range
    min_score = st.sidebar.slider("Minimum Score", 0, 100, 0)
    
    # Show polarizing only
    show_polarizing_only = st.sidebar.checkbox("üß® Polarizing Content Only")
    
    # Apply filters
    filtered_df = scores_df.copy()
    
    if selected_platform != 'All':
        filtered_df = filtered_df[filtered_df['platform'] == selected_platform]
    
    if selected_type != 'All':
        filtered_df = filtered_df[filtered_df['content_type'] == selected_type]
    
    filtered_df = filtered_df[filtered_df['final_score'] >= min_score]
    
    if show_polarizing_only:
        filtered_df = filtered_df[filtered_df['is_polarizing'] == True]
    
    # Sort by score
    filtered_df = filtered_df.sort_values('final_score', ascending=False)
    
    # Key metrics
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("Total Content", len(filtered_df))
    
    with col2:
        avg_score = filtered_df['final_score'].mean() if not filtered_df.empty else 0
        st.metric("Avg Score", f"{avg_score:.1f}")
    
    with col3:
        must_watch = len(filtered_df[filtered_df['final_score'] >= 80])
        st.metric("üî• Must Watch", must_watch)
    
    with col4:
        polarizing = len(filtered_df[filtered_df['is_polarizing'] == True])
        st.metric("üß® Polarizing", polarizing)
    
    st.divider()
    
    # Top ranked content
    st.header("üèÜ Top Ranked Content")
    
    if filtered_df.empty:
        st.warning("No content matches the current filters")
        return
    
    # Display table
    display_df = filtered_df.head(50).copy()
    
    # Format columns
    display_df['Score'] = display_df['final_score'].apply(lambda x: f"{x:.1f}")
    display_df['Reviews'] = display_df['review_count']
    display_df['Label'] = display_df['label']
    display_df['Platform'] = display_df['platform']
    display_df['Type'] = display_df['content_type'].apply(lambda x: 'üì∫ TV' if x == 'tv' else 'üé¨ Movie')
    display_df['Year'] = display_df['release_year'].apply(
        lambda x: str(int(x)) if pd.notna(x) else 'N/A'
    )
    display_df['Status'] = display_df.apply(
        lambda row: 'üß® Polarizing' if row['is_polarizing'] 
                   else '‚ö†Ô∏è Low Reviews' if row['review_count'] < 3
                   else '‚úì', 
        axis=1
    )
    
    # Select columns to show
    table_cols = ['title', 'Platform', 'Type', 'Year', 'Score', 'Label', 'Reviews', 'Status']
    
    st.dataframe(
        display_df[table_cols],
        column_config={
            "title": st.column_config.TextColumn("Title", width="large"),
            "Platform": st.column_config.TextColumn("Platform", width="medium"),
            "Type": st.column_config.TextColumn("Type", width="small"),
            "Year": st.column_config.TextColumn("Year", width="small"),
            "Score": st.column_config.TextColumn("Score", width="small"),
            "Label": st.column_config.TextColumn("Label", width="medium"),
            "Reviews": st.column_config.NumberColumn("Reviews", width="small"),
            "Status": st.column_config.TextColumn("Status", width="small")
        },
        height=600,
        hide_index=True
    )
    
    # Detailed view
    st.subheader("üìã Detailed Rankings")
    
    for idx, row in display_df.head(20).iterrows():
        polarizing_emoji = 'üß® ' if row['is_polarizing'] else ''
        
        with st.expander(f"{polarizing_emoji}{row['title']} - {row['label']}"):
            col1, col2 = st.columns([1, 2])
            
            with col1:
                if row.get('poster_path'):
                    poster_url = f"https://image.tmdb.org/t/p/w200{row['poster_path']}"
                    st.image(poster_url, width=150)
                
                tmdb_id = row.get('tmdb_id')
                content_type = row.get('content_type')
                if tmdb_id and content_type:
                    tmdb_url = f"https://www.themoviedb.org/{'tv' if content_type == 'tv' else 'movie'}/{tmdb_id}"
                    st.markdown(f"[View on TMDb]({tmdb_url})")
            
            with col2:
                if row.get('overview'):
                    st.write("**Overview:**")
                    st.write(row['overview'][:300] + "..." if len(row['overview']) > 300 else row['overview'])
                
                st.write("**Score Breakdown:**")
                
                score_data = {
                    'Source': ['YouTube', 'Reddit', 'IMDB'],
                    'Score': [
                        row.get('youtube_score', 0),
                        row.get('reddit_score', 0),
                        row.get('imdb_score', 0)
                    ]
                }
                
                fig = go.Figure(data=[
                    go.Bar(
                        x=score_data['Source'],
                        y=score_data['Score'],
                        marker_color=['#FF6B6B', '#FF8C42', '#4ECDC4'],
                        text=[f"{s:.1f}" for s in score_data['Score']],
                        textposition='auto'
                    )
                ])
                
                fig.update_layout(
                    height=250,
                    margin=dict(l=0, r=0, t=20, b=0),
                    yaxis_range=[0, 100],
                    yaxis_title="Score",
                    showlegend=False
                )
                
                st.plotly_chart(fig, use_container_width=True, key=f"chart_{idx}")
                
                col_a, col_b, col_c = st.columns(3)
                with col_a:
                    st.metric("Reviews", row['review_count'])
                with col_b:
                    st.metric("Positive %", f"{row['positive_ratio']*100:.0f}%")
                with col_c:
                    if row['is_polarizing']:
                        st.markdown("üß® **POLARIZING**")
    
    # Analytics
    st.divider()
    st.header("üìä Analytics")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("Score Distribution")
        
        fig = px.histogram(
            filtered_df,
            x='final_score',
            nbins=20,
            labels={'final_score': 'Score', 'count': 'Count'},
            color_discrete_sequence=['#667eea']
        )
        
        fig.update_layout(
            showlegend=False,
            height=300,
            margin=dict(l=0, r=0, t=0, b=0)
        )
        
        st.plotly_chart(fig, use_container_width=True)
    
    with col2:
        st.subheader("Platform Comparison")
        
        platform_avg = filtered_df.groupby('platform')['final_score'].mean().sort_values(ascending=False)
        
        fig = go.Figure(data=[
            go.Bar(
                x=platform_avg.index,
                y=platform_avg.values,
                marker_color='#764ba2',
                text=[f"{v:.1f}" for v in platform_avg.values],
                textposition='auto'
            )
        ])
        
        fig.update_layout(
            showlegend=False,
            height=300,
            margin=dict(l=0, r=0, t=0, b=0),
            yaxis_range=[0, 100],
            yaxis_title="Avg Score"
        )
        
        st.plotly_chart(fig, use_container_width=True)
    
    # Footer
    st.divider()
    col1, col2 = st.columns(2)
    with col1:
        if st.button("üîÑ Refresh Data", key="refresh_watch"):
            st.cache_data.clear()
            st.rerun()
    with col2:
        st.caption(f"Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

# ============================================================================
# DISCOVER TAB
# ============================================================================

def render_discover_tab():
    st.header("üîç Discover - Browse by Category")
    st.caption("Classics, genres, and hidden gems available on your platforms")
    
    # Load discover data
    discover_df, error = load_discover_data()
    
    if error:
        st.error(f"‚ö†Ô∏è {error}")
        st.info("""
        **To fix this:**
        1. Create the `discover_content` table in Supabase (see SQL in streaming_tracker_v3.py)
        2. Run: `python3 streaming_tracker_v3.py`
        3. Wait for Discover flow to complete
        4. Refresh this page
        """)
        return
    
    # Stats
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("Total Content", len(discover_df))
    
    with col2:
        classics_count = len(discover_df[discover_df['category'] == 'classics'])
        st.metric("‚≠ê Classics", classics_count)
    
    with col3:
        gems_count = len(discover_df[discover_df['category'] == 'underdog'])
        st.metric("üíé Hidden Gems", gems_count)
    
    with col4:
        genre_count = len(discover_df[discover_df['category'].str.startswith('genre_')])
        st.metric("üé≠ Genre Picks", genre_count)
    
    st.divider()
    
    # Sidebar filters
    st.sidebar.header("üîç Discover Filters")
    
    # Category filter
    categories = {
        'All': None,
        '‚≠ê Classics': 'classics',
        'üíé Hidden Gems': 'underdog',
        'üé≠ Action': 'genre_action',
        'üëª Horror': 'genre_horror',
        'üòÇ Comedy': 'genre_comedy',
        'üé¨ Drama': 'genre_drama',
        'üî™ Thriller': 'genre_thriller'
    }
    
    selected_category = st.sidebar.selectbox("Category", list(categories.keys()))
    
    # Platform filter
    platforms = ['All'] + sorted(discover_df['platform'].unique().tolist())
    selected_platform = st.sidebar.selectbox("Platform", platforms, key="discover_platform")
    
    # Content type filter
    content_types = ['All', 'Movie', 'TV Show']
    selected_type = st.sidebar.selectbox("Type", content_types, key="discover_type")
    
    # Min rating filter
    min_rating = st.sidebar.slider("Min IMDB Rating", 0.0, 10.0, 6.0, 0.5)
    
    # Apply filters
    filtered_df = discover_df.copy()
    
    if selected_category != 'All':
        filtered_df = filtered_df[filtered_df['category'] == categories[selected_category]]
    
    if selected_platform != 'All':
        filtered_df = filtered_df[filtered_df['platform'] == selected_platform]
    
    if selected_type != 'All':
        type_map = {'Movie': 'movie', 'TV Show': 'tv'}
        filtered_df = filtered_df[filtered_df['content_type'] == type_map[selected_type]]
    
    filtered_df = filtered_df[filtered_df['imdb_rating'] >= min_rating]
    
    # Sort by rating
    filtered_df = filtered_df.sort_values('imdb_rating', ascending=False)
    
    if filtered_df.empty:
        st.warning("No content matches your filters")
        return
    
    # Display grid
    st.subheader(f"Found {len(filtered_df)} titles")
    
    # Create display dataframe
    display_df = filtered_df.copy()
    display_df['Rating'] = display_df['imdb_rating'].apply(lambda x: f"‚≠ê {x:.1f}" if pd.notna(x) else "N/A")
    display_df['Year'] = display_df['release_year'].apply(lambda x: str(int(x)) if pd.notna(x) else 'N/A')
    display_df['Type'] = display_df['content_type'].apply(lambda x: 'üì∫ TV' if x == 'tv' else 'üé¨ Movie')
    
    # Category badge
    def get_category_name(cat):
        if cat == 'classics':
            return '‚≠ê Classic'
        elif cat == 'underdog':
            return 'üíé Hidden Gem'
        elif cat.startswith('genre_'):
            genre = cat.replace('genre_', '').title()
            return f'üé≠ {genre}'
        return cat
    
    display_df['Category'] = display_df['category'].apply(get_category_name)
    
    # Table view
    st.dataframe(
        display_df[['title', 'platform', 'Type', 'Category', 'Year', 'Rating']].head(50),
        column_config={
            "title": st.column_config.TextColumn("Title", width="large"),
            "platform": st.column_config.TextColumn("Platform", width="medium"),
            "Type": st.column_config.TextColumn("Type", width="small"),
            "Category": st.column_config.TextColumn("Category", width="medium"),
            "Year": st.column_config.TextColumn("Year", width="small"),
            "Rating": st.column_config.TextColumn("IMDB", width="small")
        },
        height=600,
        hide_index=True
    )
    
    # Detailed cards
    st.divider()
    st.subheader("üìã Detailed View")
    
    for idx, row in display_df.head(20).iterrows():
        cat_emoji = '‚≠ê' if row['category'] == 'classics' else 'üíé' if row['category'] == 'underdog' else 'üé≠'
        
        with st.expander(f"{cat_emoji} {row['title']} ({row['Year']}) - {row['Rating']}"):
            col1, col2 = st.columns([1, 2])
            
            with col1:
                if row.get('poster_path'):
                    poster_url = f"https://image.tmdb.org/t/p/w200{row['poster_path']}"
                    st.image(poster_url, width=150)
                
                st.markdown(f"**Platform:** {row['platform']}")
                st.markdown(f"**Type:** {row['Type']}")
                st.markdown(f"**Category:** {row['Category']}")
                
                tmdb_id = row.get('tmdb_id')
                content_type = row.get('content_type')
                if tmdb_id and content_type:
                    tmdb_url = f"https://www.themoviedb.org/{'tv' if content_type == 'tv' else 'movie'}/{tmdb_id}"
                    st.markdown(f"[View on TMDb]({tmdb_url})")
            
            with col2:
                if row.get('overview'):
                    st.write("**Overview:**")
                    st.write(row['overview'])
                
                col_a, col_b, col_c = st.columns(3)
                with col_a:
                    st.metric("IMDB Rating", f"{row['imdb_rating']:.1f}")
                with col_b:
                    st.metric("Release Year", row['Year'])
                with col_c:
                    if row.get('popularity'):
                        st.metric("Popularity", f"{row['popularity']:.0f}")
    
    # Footer
    st.divider()
    col1, col2 = st.columns(2)
    with col1:
        if st.button("üîÑ Refresh Data", key="refresh_discover"):
            st.cache_data.clear()
            st.rerun()
    with col2:
        st.caption(f"Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

if __name__ == "__main__":
    main()
